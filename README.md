# satisfactory-graphqlserver-dependencies

This project contains the third-party C++ dependencies for [satisfactory-graphqlserver](https://github.com/cosmopetrich/satisfactory-graphqlserver).

It is used as a git submodule from that project, and artifacts which are too big for git are attached to its releases in a zipfile.

## License

The configuration of this repository itself is licensed under the GNU GPL 3.0.
However, the headers and binaries included in it are under the licenses of
[cppgraphqlgen](https://github.com/microsoft/cppgraphqlgen) (MIT), 
[uWebSockets](https://github.com/uNetworking/uWebSockets) (Apache 2.0), and their various dependencies.
These include Boost (BSL), PETGL (BSL), libuv (MIT), and zlib (zlib). See the .LICENSES directory.

## Building newer versions

Edit `*/vcpkg.json` and bump the `builtin-baseline` field to a newer commit ID on the [microsoft/vcpkg](https://github.com/microsoft/vcpkg) repository.
If you have vcpkg installed locally then you can use the [x-update-baseline command](https://learn.microsoft.com/en-us/vcpkg/commands/update-baseline) to do it for you.

Commit and push. Github Actions will build PRs which change the vcpkg config as a form of basic testing, and commits to master will automatically be turned into draft releases if the vcpkg config has changed. Builds of commits that don't change that config can be built triggered from the Actions page.

When Actions is done, visit [the releases page](https://github.com/cosmopetrich/satisfactory-graphqlserver-dependencies/releases) to promote draft PRs to real ones or delete unnecessary drafts
Once the release has been published you should update the submodule in the main repository.

```bash
cd Source/ThirdParty
git pull
cd -
git commit Source/ThirdParty -m "Bump ThirdParty"
git push
```

## Misc notes

### Static linking

Use of the static Windows build target is due to the fact that [it makes things slightly easier](https://docs.ficsit.app/satisfactory-modding/latest/Development/Cpp/thirdparty.html),
since I'm not sure if there's much benefit to using DLLs when we need to ship our own copy of them with the mod anyway.
Though note that [this StackOverflow question](https://stackoverflow.com/questions/140061/when-to-use-dynamic-vs-static-libraries) contains some back and forth on whether the runtime linker for DLLs might be more memory-efficient.

### Source of headers

The header files are the ones generated by vcpkg's Windows target. The differences between these and those produced by the Linux target appear to be:
 - Line endings.
 - In zlib, `Z_HAVE_UNISTD_H` is enabled on Linux but not on Windows.

### Custom triplets

For Windows, a custom triplet is used. It can be found in [.vcpkg/triplets](.vcpkg/triplets) and is a copy of the upstream
[x64-windows-static-md-release](https://github.com/microsoft/vcpkg/blob/b505fa789fd96eb5496a2e42c651c169e8460d27/triplets/community/x64-windows-static-md-release.cmake)
with the tooling version set to the same version which the UE compiler chooses.

This was done to avoid the compiler erroring on "unresolved external symbol _Cnd_timedwait_for". That symbol was added in 
[STL#4457](https://github.com/microsoft/STL/pull/4457) which was was in turn included in
[VS 2022 v17.11](https://github.com/microsoft/STL/releases/tag/vs-2022-17.11).
When `cppgraphqlgen` is compiled using a newer version of MSVC it will generate code which uses that symbol.
Then, when UE goes to compile FactoryGame with an older version of MSVC it will see the unknown symbol and error out.

While building with anything <=17.10 would fix this problem, it seems safest to try to use the same version. This was done by:
 1. Checking the UE build log at `%localappdata%/UnrealBuildTool/Log.txt` to see which version it uses.
    Look for a line starting with "Using Visual Studio 2022", the version number will be something along the lines of `14.36.32532`.
 2. Specifying the version in the vcpkg triplet using [VCPKG_PLATFORM_TOOLSET_VERSION](https://learn.microsoft.com/en-us/vcpkg/users/triplets#vcpkg_platform_toolset_version). 3. Comparing the MSVC version mentioned in [the SF modding documentation](https://docs.ficsit.app/satisfactory-modding/latest/Development/BeginnersGuide/dependencies.html#ManuallySelectComponents)
    with [the list of VS component IDs](https://learn.microsoft.com/en-us/visualstudio/install/workload-component-id-vs-build-tools?view=vs-2022).
    The underlying componet ID should be in the form `Microsoft.VisualStudio.Component.VC.{W}.{X}.{Y}.{Z}.x86.x64` for MSVC `(v{W}.{X}-{Y}.{Z})`.
 4. Ensuring that version is installed in the GHA runner. While there is a [third-party action](https://github.com/thepwrtank18/install-vs-components/)
    which does it, given that it's only a single command we'll just run it ourselves. 
    See [the VS docs on command-line options](https://learn.microsoft.com/en-us/visualstudio/install/use-command-line-parameters-to-install-visual-studio?view=vs-2022).

Note that if you have multiple MSVC components installed then VS may choose a newer version of the toolchain.
A better way to check may be as follows.
 1. Update the GHA configuration so it installs whichever version of MSVC is specified by docs.ficsit.app.
 2. Run the build, it will likely fail.
 3. Compare the output of the two "Show available MSVC toolchains" build steps.
 4. Update the triplet to refer to the version which appeared in the second step.

This version used will likely need to change if CSS move to a newer version of UE or SML otherwise updates the recommended MSVC.

Currently, Linux is just built against whatever GCC is available though that should likely be changed as well via a similar process.


NB: installs 14.34.31933 == VC.14.34.17.4.x86.x64
    installs 14.36.32532 == VC.14.36.17.6.x86.x64

### Custom port of cppgraphqlgen

By default, cppgraphqlgen builds the CLI tools `clientgen` and `schemagen` which use [boost/program_options](https://www.boost.org/doc/libs/1_63_0/doc/html/program_options.html)
and some related dependencies. Building the version of cppgraphqlgen which we pass to UE without those tools allows us to avoid shipping extra dependencies around.


### Github artifacts

While the headers are checked in to git, the libs are far too large: a couple of hundred MB in total. Github-hosted LFS isn't a great solution as even a couple of users cloning the repository will quickly eat throught the monthly transfer quota. Instead, these larger files are zipped and attached to the project's Github release. The logic used to obtain these files should be something like the following.

 1. If `ThirdParty/*/lib` doesn't exist, the release artifact is needed.
 2. If `ThirdParty/*/.VERSION` doesn't match `ThirdParty/.VERSION`, the release artifact is needed.
 3. Remove `ThirdParty/*/lib` if it exists.
 4. Download the artifact from the release with a name matching the content of `ThirdParty/.VERSION`..
 5. Extract it to `ThirdParty/*/lib` so that `ThirdParty/*/lib/{Linux,Win64}` exist.
